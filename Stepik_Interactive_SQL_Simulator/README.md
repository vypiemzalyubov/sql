## 1.1	Отношение (таблица)

**Основные понятия реляционных баз данных**

Реляционная модель определяет способ представления данных (структуру данных), методы защиты данных (целостность данных), и операции, которые можно выполнять с данными
(манипулирование данными)
Эта модель лежит в основе всех реляционных баз данных до настоящего времени

**Основные принципы реляционных БД:**

- все данные на концептуальном уровне представляются в виде объектов, заданных в виде строк и столбцов, называемых отношением, более распространенное название - таблица
- в пересечение строки и столбца таблицы можно занести только одно значение
- все операции выполняются над целыми отношениями и результатом этих операций является отношение

**Терминология реляционных БД:**

**Отношение**  – это структура данных целиком, набор записей (таблица)

**Кортеж** – это каждая строка, содержащая данные (запись). Все кортежи в отношении должны быть различны

**Мощность** – число кортежей в таблице (число записей). Мощность отношения может быть любой (от 0 до бесконечности), порядок следования кортежей - неважен

**Атрибут** – это столбец в таблице (поле) 

**Размерность** – это число атрибутов в таблице (число полей). Размерность отношения должна быть больше 0, порядок следования атрибутов существенен

**Домен атрибута** – это допустимые значения (неповторяющиеся), которые можно занести в поле

![db](https://ucarecdn.com/5c077c69-ade0-401a-a9f0-d7efdd6c0ceb/)

---

### Отношение, реляционная модель

Рекомендации при создании таблиц:

**Имя таблицы**	

- может включать английские буквы, цифры и знак подчеркивания, должно начинаться с буквы
- имя должно быть уникальным в пределах базы данных

  *Рекомендуется:*	
  - чтобы имя было существительным в единственном числе
  - имя должно быть понятным и соответствовать тому объекту, который оно описывает
  - имя должно быть как можно короче, максимум до 10 символов
					
**Атрибуты таблицы**	

- может включать английские буквы, цифры и знак подчеркивания, должно начинаться с буквы
- имя поля должно быть уникальным в пределах таблицы
						
  *Рекомендуется:*	
  - имя должно быть понятным и соответствовать тем данным, которые хранятся в поле
  - имя может состоять из нескольких слов, тогда слова разделяются подчеркиванием, после подчеркивания слово пишется с маленькой буквы

**Поле id**
- включить ключевое поле id, которое является ОБЯЗАТЕЛЬНЫМ ЭЛЕМЕНТОМ каждой реляционной таблицы. Ключевое поле является уникальным для каждой записи, однозначно
определяет запись и в дальнейшем будет использоваться для связей с другими таблицами

  *Рекомендуется:*
  - имя должно состоять  из двух частей: начинаться с названия таблицы, которой поле принадлежит, затем через подчеркивание необходимо указать id

---	

### Выбор типов данных для полей

Основные типы данных SQL:
| Тип данных | Описание | Пример |
| --- | ------ | --- |
|**INTEGER(INT)**|Целое число (от -2 147 483 648 до 2 147 483 647)|-567 1205|
|**DECIMAL** **NUMERIC**|Вещественное число, в скобках указывается максимальная длина числа (включает символы слева и справа от десятичной запятой) и количество знаков после запятой. Можно использовать оба этих типа, они эквивалентны, принимают значения в диапазоне -10 * 38+1 до 10 * 38-1|34.6 -3.294|
|**DATE**|Дата в формате ГГГГ-ММ-ДД|2020-07-26 2021-01-03|
|**VARCHAR**|Строка длиной не более 255 символов, в скобках указывается максимальная длина строки, которая может храниться в поле|пример описание|

*Рекомендации по выбору типов данных для полей таблицы:*
- Выбирайте минимальный тип данных исходя из максимального значения поля (если максимальный текст, который может быть записан в поле, имеет длину 25 символов, значит нужно использовать тип VARCHAR(25))
- Для описания ключевого поля используйте описание INT PRIMARY KEY AUTO_INCREMENT (в поле будут заноситься различные целые числа, при этом они будут автоматически генерироваться, шаг +1))
	
---	
	
### Создание таблицы

Для создания таблицы используется SQL-запрос. В нем указывается какая таблица создается, из каких атрибутов(полей) она состоит и какой тип данных имеет каждое поле, при необходимости указывается описание полей (ключевое поле и т.д.)
```
CREATE TABLE table_name (
    column1 datatype,
    column2 datatype,
    column3 datatype
);
```	
*Рекомендации:*	
- Ключевые слова SQL не является регистрозависимым языком (CREATE и create - одно и тоже ключевое слово)
- Ключевые слова SQL и типы данных рекомендуется  записывать прописными (большими) буквами
- Имена таблиц и полей - строчными буквами
- SQL-запрос можно писать на нескольких строках
- В конце SQL-запроса ставится точка с запятой (если один запрос, то необязательно)

---

### Вставка записи в таблицу

Для занесения новой записи в таблицу используется SQL запрос, в котором указывается в какую таблицу, в какие поля заносить новые значения
```
INSERT INTO table_name (column1, column2, column3)
VALUES (value1, value2, value3);
```				
В результате выполнения запроса новая запись заносится в конец обновляемой таблицы

При составлении списка полей и списка значений необходимо учитывать следующее:
- количество полей и количество значений в списках должны совпадать
- должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый элемент списка значений должен относиться к первому столбцу в списке столбцов, второй – ко второму столбцу и т.д.
- типы данных элементов в списке значений должны быть совместимы с типами данных соответствующих столбцов таблицы (целое число можно занести в поле типа DECIMAL, обратная операция - недопустима)
- новые значения нельзя добавлять в поля, описанные как PRIMARY KEY AUTO_INCREMENT
- рекомендуется заполнять все поля записи, если же поле пропущено, значение этого поля зависит от установленных по умолчанию значений, если значения не установлены - вставляется пустое значение (NULL)

## 1.2 Выборка данных

Выборка всех данных из таблицы
```
SELECT * FROM table_name;
```		
Выборка отдельных столбцов
```
SELECT column1, column2
FROM table_name;
```
Выборка новых столбцов и присвоение им новых имен
```
SELECT column1 AS c1, column2
FROM table_name;
```				
Выборка данных с созданием вычисляемого столбца

С помощью SQL запросов можно осуществлять вычисления по каждой строке таблицы с помощью вычисляемого столбца. Для него в списке полей после оператора SELECT указывается выражение и задается имя. Выражение может включать имена столбцов, константы, знаки операций, встроенные функции
```
SELECT column1, column2, column3, column4, column3 * column4 AS calculated_column_name 
FROM table_name;
```
### Выборка данных, вычисляемые столбцы, математические функции	

| Функция | Описание | Пример |
| --- | ------ | --- |
|**CEILING(x)**|возвращает наименьшее целое число, большее или равное x (округляет до целого числа в большую сторону)|CEILING(4.2)=5; CEILING(-5.8)=-5|
|**ROUND(x,k)**|округляет значение x до k знаков после запятой, если k не указано – x округляется до целого|ROUND(4.361)=4; ROUND(5.86592,1)=5.9|
|**FLOOR(x)**|возвращает наибольшее целое число, меньшее или равное x (округляет до  целого числа в меньшую сторону)|FLOOR(4.2)=4; FLOOR(-5.8)=-6|
|**POWER(x,y)**|возведение x в степень y|POWER(3,4)=81.0|
|**SQRT(x)**|квадратный корень из x|SQRT(4)=2.0; SQRT(2)=1.41...|
|**DEGREES(x)**|конвертирует значение x из радиан в градусы|DEGREES(3) = 171.8...|
|**RADIANS(x)**|конвертирует значение x из градусов в радианы|RADIANS(180)=3.14...|
|**ABS(x)**|модуль числа x|ABS(-1) = 1; ABS(1) = 1|
|**PI()**|pi = 3.1415926...| |
```
SELECT column1, column2 ROUND(column1 * column2,2)
FROM table_name;
```

### Выборка данных, вычисляемые столбцы, логические функции

В SQL реализована возможность заносить в поле значение в зависимости от условия. Для этого используется функция IF()
```
IF(логическое_выражение, выражение_1, выражение_2)
```
Функция вычисляет логическое_выражение, если оно истина – в поле заносится значение выражения 1, в противном случае – значение выражения 2. Все три параметра IF() являются обязательными
```
SELECT title, amount, price, 
    IF(amount<4, price*0.5, price*0.7) AS sale
FROM book;
```
Допускается использование вложенных функций, вместо выражения 1 или выражения 2 может стоять новая функция IF.
	
### Выборка данных по условию

С помощью запросов можно включать в итоговую выборку не все строки исходной таблицы, а только те, которые отвечают некоторому условию. Для этого после указания таблицы, откуда выбираются данные, задается ключевое слово **WHERE** и логическое выражение, от результата которого зависит будет ли включена строка в выборку или нет. Если условие – истина, то строка(запись) включается в выборку, если ложь – нет.

Логическое выражение может включать операторы сравнения (равно **=**, не равно **<>**, больше **>**, меньше **<**, больше или равно **>=**, меньше или равно **<=**) и выражения, допустимые в SQL
```
SELECT title, price 
FROM book
WHERE price < 600;
```
В логическом выражении после **WHERE** нельзя использовать названия столбцов, присвоенные им с помощью **AS**, так как при выполнении запроса сначала вычисляется логическое выражение для каждой строки исходной таблицы, выбираются строки, для которых оно истинно, а только после этого формируется "шапка запроса" – столбцы, включаемые в запрос

### Выборка данных, логические операции

Логическое выражение после ключевого слова **WHERE** кроме операторов сравнения и выражений может включать логические операции (И **and**, ИЛИ **or**, НЕ **not**) и круглые скобки, изменяющие приоритеты выполнения операций

**Приоритеты операций:**	
1) круглые скобки
2) умножение (*), деление (/)
3) сложение (+), вычитание (-)
4) операторы сравнения (=, >, <, >=, <=, <>)
5) NOT
6) AND
7) OR
```							
SELECT title, author, price 
FROM book
WHERE price > 600 AND author = 'Булгаков М.А.';
```

### Выборка данных, операторы BETWEEN, IN

Логическое выражение после ключевого слова WHERE может включать операторы  **BETWEEN** и **IN**. Приоритет  у этих операторов такой же как у операторов сравнения, то есть они выполняются раньше, чем **NOT**, **AND**, **OR**

Оператор **BETWEEN** позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы
```
SELECT title, amount 					
FROM book
WHERE amount BETWEEN 5 AND 14;
```			
Оператор **IN** позволяет выбрать данные, соответствующие значениям из списка
```
SELECT title, price 
FROM book
WHERE author IN ('Булгаков М.А.', 'Достоевский Ф.М.');
```

### Выборка данных с сортировкой

При выборке можно указывать столбец или несколько столбцов, по которым необходимо отсортировать отобранные строки, для этого используются ключевые слова **ORDER BY**, после которых задаются имена столбцов, при этом строки сортируются по первому столбцу, если указан второй столбец, сортировка осуществляется только для тех строк, у которых значения первого столбца одинаковы

По умолчанию **ORDER BY** выполняет сортировку по возрастанию

Чтобы управлять направлением сортировки вручную, после имени столбца указывается ключевое слово **ASC** (по возрастанию) или **DESC** (по убыванию), либо **RAND()** - случайная

Столбцы после ключевого слова **ORDER BY** можно задавать:	
- названием столбца
- номером столбца
- именем столбца (указанным после AS)
```														
SELECT title, author, price
FROM book
ORDER BY title;
```				
Если названия столбцов заключены в кавычки, то при использовании их в сортировке, необходимо записывать их БЕЗ КАВЫЧЕК

### Выборка данных, оператор LIKE

Оператор **LIKE** используется для сравнения строк. В отличие от операторов отношения равно (=) и не равно (<>), LIKE позволяет сравнивать строки не на полное совпадение (не совпадение), а в соответствии с шаблоном. Шаблон может включать обычные символы и символы-шаблоны. При сравнении с шаблоном, его обычные символы должны в точности совпадать с символами, указанными в строке. Символы-шаблоны могут совпадать с произвольными элементами символьной строки

**Символ-шаблон:**	
- **%** - Любая строка, содержащая ноль или более символов (`SELECT * FROM book WHERE author LIKE '%М.%'` - выполняет поиск и выдает все книги, инициалы авторов которых содержат «М.»)
- **_** (подчеркивание) - Любой одиночный символ (`SELECT * FROM book WHERE title LIKE 'Поэм_'` - выполняет поиск и выдает все книги, названия которых либо «Поэма», либо «Поэмы» и пр.)
					
Для обозначения одного любого символа используется "_", следовательно для обозначения 5 символов используется 5 подряд символов подчеркивания. Для того чтобы вывести названия, состоящие из любого количества символов после **LIKE** можно использовать шаблон "%", с помощью которого отбираются строки, состоящие из любого количества символов, в том числе и "пустые", поскольку % заменяет любое количество символов, в том числе и нулевое

Чтобы указать, что в названии должен быть хотя бы один символ, можно использовать один из эквивалентных шаблонов:
- "_%" 	- сначала идет символ, а за ним любое количество символов
- "%_" 	- сначала идет любое количество символов, а затем обязательный символ
- "%_%" - сначала идет любое количество символов, потом обязательный символ, а за ним любое количество символов

Слово "и" может располагаться в названии в следующих позициях (при условии, что слова отделяются друг от друга пробелами):
- в середине -  "_% и _%" - сначала идет любое количество символов (один обязательный), потом обязательный пробел, а за ним "и", снова обязательный пробел, и наконец любое количество символов (один обязательный)
- в начале - "и _%" - сначала идет "и", обязательный пробел и любое количество символов (один обязательный)
- в конце - "_% и" - сначала идет любое количество символов, затем обязательный пробел и буква "и" одно слово в названии - "и"

*Вместо "_%" можно использовать эквивалентные шаблоны "%_" и "%_%"*

В качестве обязательного символа ("_"), может быть и пробел, но, к сожалению, шаблоны для LIKE не позволяют исключить какой-то символ. Это можно сделать только с помощью регулярных выражений

Отсутствие пробела в названии означает, что оно состоит из одного слова. Чтобы это проверить используется оператор **NOT LIKE**, который отберет все названия, в которых нет пробелов (NOT LIKE "% %")

## 1.3 Запросы, групповые операции

### Выбор уникальных элементов столбца

Чтобы отобрать уникальные элементы некоторого столбца используется ключевое слово **DISTINCT**, которое размещается сразу после **SELECT**
```
SELECT DISTINCT author
FROM book;
```				

### Выборка данных, групповые функции SUM и COUNT

При группировке над элементами столбца, входящими в группу можно выполнить различные действия, например, просуммировать их или найти количество элементов в группе
```
SELECT author, sum(amount), count(amount)
FROM book
GROUP BY author;

где SUM - посчитает количество книг по каждому автору, а COUNT - количество записей по каждому автору
```

Функцию **COUNT()** можно применять к любому столбцу, в том числе можно использовать и \*, если таблица не содержит пустых значений. Если же в столбцах есть значения Null, то COUNT(*) подсчитывает  все записи, относящиеся к группе, в том числе и со значением NULL

COUNT(имя_столбца) — возвращает количество записей конкретного столбца (только NOT NULL), относящихся к группе
																				
### Выборка данных, групповые функции MIN, MAX и AVG

К групповым функциям SQL относятся: **MIN()**, **MAX()** и **AVG()**, которые вычисляют минимальное, максимальное и среднее значение элементов столбца, относящихся к группе
```
SELECT author, MIN(price) AS min_price
FROM book
GROUP BY author;
```				

### Выборка данных c вычислением, групповые функции

В качестве аргумента групповых функций SQL может использоваться не только столбец, но и любое допустимое в SQL арифметическое выражение
```
SELECT author, SUM(price * amount) AS Стоимость
FROM book
GROUP BY author;
```				
Групповые функции могут быть элементами выражений	
```
SELECT author, ROUND(AVG(price),2) AS Средняя_цена
FROM book
GROUP BY author;
```													

### Вычисления по таблице целиком

Групповые функции позволяют вычислять итоговые значения по всей таблице. Для этого после ключевого слова **SELECT** указывается групповая функция для выражения или имени столбца, а ключевые слова **GROUP BY** опускаются
```
SELECT SUM(amount) AS Количество
FROM book;
```

### Выборка данных по условию, групповые функции

В запросы с групповыми функциями можно включать условие отбора строк, которое в обычных запросах записывается после **WHERE**. В запросах с групповыми функциями вместо **WHERE** используется ключевое слово **HAVING**, которое размещается после оператора **GROUP BY**
```
SELECT author,
	MIN(price) AS Минимальная_цена, 
	MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000;
```				
Также в запросах с группировкой можно сортировать данные
```
SELECT author,
	MIN(price) AS Минимальная_цена, 
	MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000 
ORDER BY Минимальная_цена DESC;
```

### Выборка данных по условию, групповые функции, WHERE и HAVING

**WHERE** и **HAVING** могут использоваться в одном запросе

При этом необходимо учитывать порядок выполнения  SQL запроса на выборку на СЕРВЕРЕ:
- FROM
- WHERE
- GROUP BY
- HAVING
- SELECT
- ORDER BY
		
Сначала определяется таблица, из которой выбираются данные (**FROM**), затем из этой таблицы отбираются записи в соответствии с условием **WHERE**, выбранные данные агрегируются (**GROUP BY**), из агрегированных записей выбираются те, которые удовлетворяют условию после **HAVING**. Потом формируются данные результирующей выборки, как это указано после **SELECT** (вычисляются выражения, присваиваются имена и пр.). Результирующая выборка сортируется, как указано после **ORDER BY**
```
SELECT author,
	MIN(price) AS Минимальная_цена,
	MAX(price) AS Максимальная_цена
FROM book
WHERE author <> 'Есенин С.А.'
GROUP BY author
HAVING SUM(amount) > 10;
```

## 1.4 Вложенные запросы

### Вложенный запрос, возвращающий одно значение

Вложенный запрос, возвращающий одно значение, может использоваться в условии отбора записей **WHERE** как обычное значение совместно с операциями =, <>, >=, <=, >, <
```
SELECT title, author, price, amount
FROM book
WHERE price = (
	SELECT MIN(price) 
	FROM book
);
```					  
**Использование вложенного запроса в выражении**

Вложенный запрос, возвращающий одно значение, может использоваться в выражениях как обычный операнд, например, к нему можно что-то прибавить, вычесть и пр.
```
SELECT title, author, amount 
FROM book
WHERE ABS(amount - (SELECT AVG(amount) FROM book)) >3;		
```								
### Вложенный запрос, оператор IN

Вложенный запрос может возвращать несколько значений одного столбца.  Тогда его можно использовать в разделе **WHERE** совместно с оператором **IN**

	WHERE имя_столбца IN (вложенный запрос, возвращающий один столбец)	

Оператор **IN** определяет, совпадает ли значение столбца с одним из значений, содержащихся во вложенном запросе. При этом логическое выражение после **WHERE** получает значение истина. Оператор **NOT IN** выполняет обратное действие – выражение истинно, если значение столбца не содержится во вложенном запросе
```
SELECT title, author, amount, price
FROM book
WHERE author IN (
	SELECT author 
	FROM book 
	GROUP BY author 
	HAVING SUM(amount) >= 12
);
```

### Вложенный запрос, операторы ANY и ALL

Вложенный запрос, возвращающий несколько значений одного столбца, можно использовать для отбора записей с помощью операторов **ANY** и **ALL** совместно с операциями отношения (=, <>, <=, >=, <, >)

Операторы **ANY** и **ALL** используются в SQL для сравнения некоторого значения с результирующим набором вложенного запроса, состоящим из одного столбца.
При этом тип данных столбца, возвращаемого вложенным запросом, должен совпадать с типом данных столбца (или выражения), с которым происходит сравнение

При использовании оператора **ANY** в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно хотя бы для одного элемента результирующего запроса

**Как работает оператор ANY:**
- **amount > ANY (10, 12)** - эквивалентно amount > 10
- **amount < ANY (10, 12)** - эквивалентно amount < 12
- **amount = ANY (10, 12)** - эквивалентно (amount = 10) OR (amount = 12), а также amount IN (10,12)
- **amount <> ANY (10, 12)** - вернет все записи с любым значением amount, включая 10 и 12

При использовании оператора **ALL** в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно для всех элементов результирующего запроса

**Как работает оператор ALL:**
- **amount > ALL (10, 12)** - эквивалентно amount > 12
- **amount < ALL (10, 12)** - эквивалентно amount < 10
- **amount = ALL (10, 12)** - не вернет ни одной записи, так как эквивалентно (amount = 10) AND (amount = 12)
- **amount <> ALL (10, 12)** - вернет все записи кроме тех,  в которых amount равно 10 или 12

Операторы **ALL** и **ANY** можно использовать **только с вложенными запросами**

В примерах выше (10, 12) приводится как результат вложенного запроса просто для того, чтобы показать как эти операторы работают. В запросах так записывать нельзя
```
SELECT title, author, amount, price
FROM book
WHERE amount < ALL (
	SELECT AVG(amount) 
	FROM book 
	GROUP BY author 
);
```					   
```
SELECT title, author, amount, price
FROM book
WHERE amount < ANY (
	SELECT AVG(amount) 
	FROM book 
	GROUP BY author 
);
```

### Вложенный запрос после SELECT

Вложенный запрос может располагаться после ключевого слова **SELECT**. В этом случае результат выполнения запроса выводится в отдельном столбце результирующей таблицы. При этом результатом запроса может быть **только одно значение**, тогда оно будет повторяться во всех строках. Также вложенный запрос может использоваться в выражениях
```
SELECT title, author, amount, 
	(
	SELECT AVG(amount) 
	FROM book
	) AS Среднее_количество 
FROM book
WHERE abs(amount - (SELECT AVG(amount) FROM book)) >3;
```

## 1.5 Запросы корректировки данных

### Добавление записей из другой таблицы

С помощью запроса на добавление можно не только добавить в таблицу конкретные значения (список **VALUES**), но и записи из другой таблицы, отобранные с помощью запроса на выборку. В этом случае вместо раздела **VALUES** записывается запрос на выборку, начинающийся с **SELECT**. В нем можно использовать **WHERE**, **GROUP BY**, **ORDER BY**

**Правила соответствия между полями таблицы и вставляемыми значениями из запроса:**
- количество полей в таблице и количество полей в запросе должны совпадать
- должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый столбец запроса должен относиться к первому столбцу в списке столбцов таблицы, второй – ко второму столбцу и т.д.
- типы столбцов запроса должны быть совместимы с типами данных соответствующих столбцов таблицы (целое число можно занести в поле типа DECIMAL, обратная операция – недопустима)
```	  
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply;
```
### Добавление записей, вложенные запросы

В запросах на добавление можно использовать вложенные запросы
```
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply
WHERE title NOT IN (
	SELECT title 
	FROM book
);
						
Вложенным запросом отбираются все названия книг, которые есть в таблице book
Основным запросом SELECT из таблицы supply выбираются книги, названия которых нет в результате вложенного запроса
Отобранные записи добавляются в конец таблицы book запросом на добавление INSERT
```	
	
### Запросы на обновление

Под обновлением данных подразумевается изменение значений в существующих записях таблицы. При этом возможно как изменение значений полей в группе строк (даже всех строк таблицы), так и правка значения поля отдельной строки

Изменение записей в таблице реализуется с помощью запроса **UPDATE**
```
UPDATE таблица SET поле = выражение

таблица – имя таблицы, в которой будут проводиться изменения
поле – поле таблицы, в которое будет внесено изменение
выражение – выражение, значение которого будет занесено в поле
```
```
UPDATE book 
SET price = 0.7 * price;
```

С помощью запросов на обновление можно изменять не все записи в таблице (как в предыдущем запросе), а только часть из них. Для этого в запрос включается ключевое слово **WHERE**, после которого указывается условие отбора строк для изменения
```
UPDATE book 
SET price = 0.7 * price 
WHERE amount < 5;
```

### Запросы на обновление нескольких столбцов

Запросом **UPDATE** можно обновлять значения нескольких столбцов одновременно
```
UPDATE таблица SET поле1 = выражение1, поле2 = выражение2
```
```
UPDATE book 
SET amount = amount - buy, buy = 0;
```

### Запросы на обновление нескольких таблиц 

В запросах на обновление можно использовать несколько таблиц, но тогда:
- для столбцов, имеющих одинаковые имена, необходимо указывать имя таблицы, к которой они относятся (book.price – столбец price из таблицы book, supply.price – столбец price из таблицы supply)
- все таблицы, используемые в запросе, нужно перечислить после ключевого слова **UPDATE**	
- в запросе обязательно условие **WHERE**, в котором указывается условие при котором обновляются данные
```
UPDATE book, supply 
SET book.amount = book.amount + supply.amount
WHERE book.title = supply.title AND book.author = supply.author;
```

### Запросы на удаление

Запросы корректировки данных позволяют удалить одну или несколько записей из  таблицы:	DELETE FROM таблица; (удалит все записи)

Запрос на удаления позволяет удалить не все записи таблицы, а только те, которые удовлетворяют условию, указанному после ключевого слова WHERE: DELETE FROM таблица
																		WHERE условие;

	Пример:	DELETE FROM supply 
			WHERE title IN (
					SELECT title 
					FROM book
					);



Запросы на создание таблицы

Новая таблица может быть создана на основе данных из другой таблицы
Для этого используется запрос SELECT, результирующая таблица которого и будет новой таблицей базы данных
При этом имена столбцов запроса становятся именами столбцов новой таблицы
 
Запрос на создание новой таблицы имеет вид:	CREATE TABLE имя_таблицы AS
						SELECT ...

	Пример:	CREATE TABLE ordering AS
		SELECT author, title, 5 AS amount
		FROM book
		WHERE amount < 4;

При создании таблицы можно использовать вложенные запросы как после SELECT, так и после WHERE


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


1.6 Запросы на выборку (Таблица "Командировки")



Оператор LIMIT

Для ограничения вывода записей в SQL используется оператор LIMIT, после которого указывается количество строк
Результирующая таблица будет иметь количество строк не более указанного после LIMIT. LIMIT размещается после раздела ORDER BY
Как правило, этот оператор используется, чтобы отобрать заданное количество отсортированных строк результата запроса

	Пример:	SELECT *
		FROM trip
		ORDER BY  date_first
		LIMIT 1;



Работа с датами

Для вычитания двух дат используется функция DATEDIFF(дата_1, дата_2), результатом которой является количество дней между дата_1 и дата_2

	Пример:	DATEDIFF('2020-04-01', '2020-03-28') = 4

		DATEDIFF('2020-05-09','2020-05-01') = 8

		DATEDIFF(date_last, date_first)
			
			

Для того, чтобы выделить номер месяца из даты используется функция MONTH(дата)

	Пример: MONTH('2020-04-12') = 4



Для того, чтобы выделить название месяца из даты используется функция MONTHNAME(дата), которая возвращает название месяца на английском языке для указанной даты

	Пример:	MONTHNAME('2020-04-12')='April'
	
Если группировка осуществляется по вычисляемому столбцу (в данном случае «вычисляется» название месяца),
то после GROUP BY можно указать как вычисляемое выражение, так и имя столбца, заданное с помощью AS
Важно отметить, что последний вариант (указать имя столбца) нарушает стандарт по порядку выполнения запросов, но иногда может встречаться на реальных платформах



В SQL есть функции, которые позволяют выделить часть даты: день(DAY()), месяц (MONTH()), год(YEAR())

	Пример:	DAY('2020-02-01') = 1
		MONTH('2020-02-01') = 2
		YEAR('2020-02-01') = 2020





1.7 Запросы корректировки (Таблица "Нарушения ПДД")



Использование временного имени таблицы (алиаса)

Чтобы не писать название таблицы каждый раз, удобно использовать алиасы

Алиас, это псевдоним, который мы присваивали столбцам после ключевого слова AS(шаг)
Алиасы так же можно использовать и для таблиц. Это становится актуальным, при увеличении числа используемых таблиц, их иногда может быть и 5 и 10 и более
Псевдонимы помогают сделать запрос чище и читабельнее

	Для присваивания псевдонима существует 2 варианта:	- с использованием ключевого слова AS 
								  FROM fine AS f, traffic_violation AS tv
														
								- а так же и без него
								  FROM fine f, traffic_violation tv
														
После присвоения таблице алиаса, он используется во всех разделах запроса, в котором алиас задан	
	
	Пример:	WHERE f.violation = tv.violation
	
	Пример:	SELECT  f.name, f.number_plate, f.violation, 
				if(
					f.sum_fine = tv.sum_fine, "Стандартная сумма штрафа", 
				if(
					f.sum_fine < tv.sum_fine, "Уменьшенная сумма штрафа", "Увеличенная сумма штрафа"
				)
			) AS description               
		FROM  fine f, traffic_violation tv
		WHERE tv.violation = f.violation and f.sum_fine IS NOT Null;



Группировка данных по нескольким столбцам

В разделе GROUP BY можно указывать несколько столбцов, разделяя их запятыми
Тогда к одной группе будут относиться записи, у которых значения столбцов, входящих в группу, равны

	Пример:	SELECT name, number_plate, violation, count(*)
		FROM fine
		GROUP BY name, number_plate, violation;
			
		- сначала записи таблицы fine разделяются на группы
		  в каждую группу включаются строки, у которых равны значения в столбцах name, number_plate и violation соответственно. Получается 6 групп
			
		- затем вычисляется функция count(*), которая определяет количество записей в каждой группе
		  получается, что к первым двум группам относятся по две записи, ко всем остальным - по одной


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


2.1 Связи между таблицами


Связь "один ко многим"

Связь «один ко многим» имеет место, когда одной записи главной таблицы соответствует несколько записей связанной таблицы, а каждой записи связанной таблицы соответствует только одна запись главной таблицы

Автор -> Книга


Связь "многие ко многим"

Связь «многие ко многим» имеет место когда каждой записи одной таблицы соответствует несколько записей во второй, и наоборот, каждой записи второй таблицы соответствует несколько записей в первой

Автор <-> Книга


Создание таблицы с внешними ключами

При создании зависимой таблицы (таблицы, которая содержит внешние ключи) необходимо учитывать, что:

	- каждый внешний ключ должен иметь такой же тип данных, как связанное поле главной таблицы;
	- необходимо указать главную для нее таблицу и столбец, по которому осуществляется связь: FOREIGN KEY (связанное_поле_зависимой_таблицы)  
	  											  REFERENCES главная_таблица (связанное_поле_главной_таблицы)
	
По умолчанию любой столбец, кроме ключевого, может содержать значение NULL. При создании таблицы это можно переопределить, используя ограничение NOT NULL для этого столбца:

CREATE TABLE таблица (
    столбец_1 INT NOT NULL, 
    столбец_2 VARCHAR(10) 
);

В созданной таблице в столбец_1 не может содержать пустое значение, а столбец_2 - может

Для внешних ключей рекомендуется устанавливать ограничение NOT NULL


Действия при удалении записи главной таблицы

С помощью выражения ON DELETE можно установить действия, которые выполняются для записей подчиненной таблицы при удалении связанной строки из главной таблицы

При удалении можно установить следующие опции:

- CASCADE: автоматически удаляет строки из зависимой таблицы при удалении связанных строк в главной таблице
- SET NULL: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL. (В этом случае столбец внешнего ключа должен     	          поддерживать установку NULL)
- SET DEFAULT: похоже на SET NULL за тем исключением, что значение внешнего ключа устанавливается не в NULL, а в значение по умолчанию для данного столбца
- RESTRICT: отклоняет удаление строк в главной таблице при наличии связанных строк в зависимой таблице

Важно! Если для столбца установлена опция SET NULL, то при его описании нельзя задать ограничение на пустое значение

	Пример: CREATE TABLE book (
   		 book_id INT PRIMARY KEY AUTO_INCREMENT, 
    		 title VARCHAR(50), 
    		 author_id INT NOT NULL, 
    		 price DECIMAL(8,2), 
    		 amount INT, 
     		 FOREIGN KEY (author_id)  REFERENCES author (author_id) ON DELETE CASCADE
		);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


2.2 Запросы на выборку, соединение таблиц

Соединение INNER JOIN

Оператор внутреннего соединения INNER JOIN соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным

	SELECT
	 ...
	FROM
    	    таблица_1 INNER JOIN  таблица_2
    	    ON условие
	 ...

Результат запроса формируется так: - каждая строка одной таблицы сопоставляется с каждой строкой второй таблицы
				   - для полученной «соединённой» строки проверяется условие соединения
				   - если условие истинно, в таблицу результата добавляется соответствующая «соединённая» строка

	Пример:		SELECT title, name_author
			FROM 
    			   author INNER JOIN book
    			   ON author.author_id = book.author_id;
			   
Поскольку поля author_id в таблицах book и author называются одинаково, необходимо в запросах указывать полную ссылку на них (book.author_id и author.author_id)

В данном запросе осуществляется соединение главной таблицы author и зависимой таблицы book по ключевому столбцу author.author_id и внешнему ключу book.author_id. При этом в результирующую таблицу запроса включаются все строки, в которых значения этих столбцов совпадают. Другими словами строки зависимой таблицы book дополняются фамилией и инициалами авторов из таблицы author


Внешнее соединение LEFT и RIGHT OUTER JOIN

Оператор внешнего соединения LEFT OUTER JOIN (можно использовать LEFT JOIN) соединяет две таблицы
Порядок таблиц для оператора важен, поскольку оператор не является симметричным

	SELECT
 	...
	FROM
    	    таблица_1 LEFT JOIN  таблица_2
    	    ON условие
	...
	
Результат запроса формируется так: - в результат включается внутреннее соединение (INNER JOIN) первой и второй таблицы в соответствии с условием
				   - затем в результат добавляются те записи первой таблицы, которые не вошли во внутреннее соединение на шаге 1, для таких записей 					 соответствующие поля второй таблицы заполняются значениями NULL
				   
Соединение RIGHT JOIN действует аналогично, только в пункте 2 первая таблица меняется на вторую и наоборот

	Пример:		SELECT name_author, title 
			FROM author LEFT JOIN book
     			ON author.author_id = book.author_id
			ORDER BY name_author;


Перекрестное соединение CROSS JOIN

Оператор перекрёстного соединения, или декартова произведения CROSS JOIN (в запросе вместо ключевых слов можно поставить запятую между таблицами) соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным

	SELECT								SELECT
 	...								...
	FROM								FROM
    	   таблица_1 CROSS JOIN  таблица_2				   таблица_1, таблица_2
	...						или		...

Результат запроса формируется так: каждая строка одной таблицы соединяется с каждой строкой другой таблицы, формируя  в результате все возможные сочетания строк двух таблиц


Запросы на выборку из нескольких таблиц

Запрос на выборку может выбирать данные из двух и более таблиц базы данных. При этом таблицы должны быть логически связаны между собой. Для каждой пары таблиц, включаемых в запрос, необходимо указать свой оператор соединения. Наиболее распространенным является внутреннее соединение INNER JOIN

	SELECT
	 ...
	FROM
    	   first 
   	   INNER JOIN  second ON first.first_id = second.first_id
   	   INNER JOIN  third  ON second.second_id = third.second_id
	...

	Пример:		SELECT title, name_author, name_genre, price, amount
			FROM
   		   	   author 
    		   	   INNER JOIN  book ON author.author_id = book.author_id
    		   	   INNER JOIN genre ON genre.genre_id = book.genre_id
			WHERE price BETWEEN 500 AND 700;


Запросы для нескольких таблиц с группировкой

В запросах с групповыми функциями могут использоваться несколько таблиц, между которыми используются различные типы соединений

	Пример:		SELECT name_author, count(title) AS Количество
			FROM 
    			   author INNER JOIN book
    			   on author.author_id = book.author_id
			GROUP BY name_author
			ORDER BY name_author;


Запросы для нескольких таблиц со вложенными запросами

В запросах, построенных на нескольких таблицах, можно использовать вложенные запросы. Вложенный запрос может быть включен: после ключевого слова SELECT, после FROM 
и в условие отбора после WHERE (HAVING)

	Пример:		SELECT name_author, SUM(amount) as Количество
			FROM 
   			 author INNER JOIN book
    			 on author.author_id = book.author_id
			GROUP BY name_author
			HAVING SUM(amount) = 
     					(SELECT MAX(sum_amount) AS max_sum_amount
      					 FROM 
          				(SELECT author_id, SUM(amount) AS sum_amount 
            				 FROM book GROUP BY author_id
          				) query_in
      			);


Вложенные запросы в операторах соединения

Вложенные запросы могут использоваться в операторах соединения JOIN. При этом им необходимо присваивать имя, которое записывается сразу после закрывающей скобки вложенного запроса

	SELECT
 	...
	FROM
    	   таблица ... JOIN  
       		(
        	SELECT ...
      	 	) имя_вложенного_запроса
    	   ON условие
	...
	
Вложенный запрос может стоять как справа, так и слева от оператора JOIN. Допускается использование двух запросов в операторах соединения

	Пример:		SELECT  name_author, name_genre
			FROM 
    			   author 
    			   INNER JOIN book ON author.author_id = book.author_id
    			   INNER JOIN genre ON  book.genre_id = genre.genre_id
			GROUP BY name_author,name_genre, genre.genre_id
			HAVING genre.genre_id IN
         					(SELECT query_in_1.genre_id
          					FROM 
              					(SELECT genre_id, SUM(amount) AS sum_amount
                				FROM book
                				GROUP BY genre_id
               					)query_in_1
          		  INNER JOIN 
             			 (SELECT genre_id, SUM(amount) AS sum_amount
               			 FROM book
                		 GROUP BY genre_id
                		 ORDER BY sum_amount DESC
                		 LIMIT 1
               			 ) query_in_2
          		 ON query_in_1.sum_amount= query_in_2.sum_amount
         		);   


Операция соединение, использование USING()

При описании соединения таблиц с помощью JOIN в некоторых случаях вместо ON и следующего за ним условия можно использовать оператор USING()

USING позволяет указать набор столбцов, которые есть в обеих объединяемых таблицах. Если база данных хорошо спроектирована, а каждый внешний ключ имеет такое же имя, как и соответствующий первичный ключ (например, genre.genre_id = book.genre_id), тогда можно использовать предложение USING для реализации операции JOIN

При этом после SELECT, при использовании столбцов из USING(), необязательно указывать, из какой именно таблицы берется столбец

	Пример:		SELECT title, name_author, author_id
			FROM 
    			   author INNER JOIN book
    			   USING(author_id);
		   

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


2.3 Запросы корректировки, соединение таблиц


Запросы на обновление, связанные таблицы

В запросах на обновление можно использовать связанные таблицы:

	UPDATE таблица_1
     		... JOIN таблица_2
     		ON выражение
     	...
	SET ...   
	WHERE ...;
	
При этом исправлять данные можно во всех используемых в запросе таблицах

	Пример:		UPDATE book 
     				INNER JOIN author ON author.author_id = book.author_id
    			 	INNER JOIN supply ON book.title = supply.title 
                         	and supply.author = author.name_author
			SET book.amount = book.amount + supply.amount,
    				supply.amount = 0   
			WHERE book.price = supply.price;

			SELECT * FROM book;
			SELECT * FROM supply;


Запросы на добавление, связанные таблицы

Запросом на добавление можно добавить записи, отобранные с помощью запроса на выборку, который включает несколько таблиц:

	INSERT INTO таблица (список_полей)
	SELECT список_полей_из_других_таблиц
	FROM 
    	   таблица_1 
      	   ... JOIN таблица_2 ON ...
    	...

	Пример:		SELECT supply.author
			FROM 
   			 author 
    			 RIGHT JOIN supply on author.name_author = supply.author
			WHERE name_author IS Null;
			
			
Запрос на обновление, вложенные запросы

Для этого используется запрос на обновление, в котором можно указать значения столбцов из других таблиц, либо использовать вложенные запросы для получения этих значений

	Пример:		UPDATE book
			SET genre_id = 
      				(
       				SELECT genre_id 
       				FROM genre 
       				WHERE name_genre = 'Роман'
      				)
			WHERE book_id = 9;


Каскадное удаление записей связанных таблиц

При создании таблицы для внешних ключей с помощью ON DELETE устанавливаются опции, которые определяют действия, выполняемые при удалении связанной строки из главной таблицы

В частности, ON DELETE CASCADE автоматически удаляет строки из зависимой таблицы при удалении связанных строк в главной таблице

	Пример:		DELETE FROM author
			WHERE name_author LIKE "Д%";

			SELECT * FROM author;
			SELECT * FROM book;


Удаление записей главной таблицы с сохранением записей в зависимой

При создании таблицы для внешних ключей с помощью ON DELETE устанавливаются опции, которые определяют действия, выполняемые при удалении связанной строки из главной таблицы.

Если задано SET NULL, то при удалении связанной строки из главной таблицы в зависимой, в столбце внешнего ключа, устанавливается значение NULL
(При этом в столбце внешнего ключа должно быть допустимо значение NULL)

	Пример:		DELETE FROM genre
			WHERE name_genre LIKE "%я";

			SELECT * FROM genre;
			SELECT * FROM book;


Удаление записей, использование связанных таблиц

При удалении записей из таблицы можно использовать информацию из других связанных с ней таблиц

	DELETE FROM таблица_1
	USING 
    		таблица_1 
    		INNER JOIN таблица_2 ON ...
	WHERE ...
	
	Пример:		DELETE FROM author
			USING 
    				author 
    				INNER JOIN book ON author.author_id = book.author_id
			WHERE book.amount < 3;

			SELECT * FROM author;
			SELECT * FROM book;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


2.4 База данных «Интернет-магазин книг», запросы на выборку


Проектирование концептуальной модели базы данных

1) Детально проанализировать предметную область и выделить те информационные объекты, которые будут храниться в базе данных

2) Для каждого выделенного информационного объекта указать его характеристики, для этого: а) сначала выделить их в описании предметной области
											  б) затем связать их с информационным объектом
											  в) перечислить характеристики, которые остались не привязанными к
											     информационным объектам (к ним необходимо вернуться при реализации связей
											     между таблицами)

3) Нарисовать схему, на которой изобразить информационные объекты

4) Установить связи между информационными объектами


Построение логической схемы базы данных

На основе концептуальной модели создается логическая модель, в которой информационные объекты описываются в виде реляционных таблиц

1) Выбрать пару таблиц из схемы

2) Разработать структуру таблиц для каждого информационного объекта. Таблица в качестве столбцов должна включать все характеристики информационного объекта,
   полученные на этапе концептуального проектирования, кроме тех, которые соответствуют названиям других информационных объектов. Они будут включены в таблицы при
   создании связей
   
3) Реализовать связь между таблицами

4) Вернуться к описанию концептуальной модели и проверить, нужно ли включить какие-то характеристики, непривязанные к информационным объектам
   Чаще всего характеристики добавляются при реализации связи «многие ко многим»

Логическая модель базы данных служит основой для физической модели, в которой определяются характеристики каждого столбца (тип и другие опции)
После создания структуры, таблицы наполняются информацией


Оператор UNION

Оператор UNION используется для объединения двух и более SQL запросов

	SELECT столбец_1_1, столбец_1_2, ...			SELECT столбец_1_1, столбец_1_2, ...
	FROM 							FROM
  	...					     или	...
	UNION							UNION ALL
	SELECT столбец_2_1, столбец_2_2, ...			SELECT столбец_2_1, столбец_2_2, ...
	FROM 							FROM
  	...							...

Важно отметить, что каждый из SELECT должен иметь в своем запросе одинаковое количество столбцов и совместимые типы возвращаемых данных. Каждый запрос может включать разделы WHERE, GROUP BY и прочие

В результате выполнения этой конструкции будет выведена таблица, имена столбцов которой соответствуют именам столбцов в первом запросе. А в таблице результата сначала
отображаются записи-результаты первого запроса, а затем второго. Если указано ключевое слово ALL, то в результат включаются все записи запросов, в противном случае -
различные

	Пример:		SELECT name_client
			FROM 
    			   buy_archive
    			   INNER JOIN client USING(client_id)
			UNION
			SELECT name_client
			FROM 
    			   buy 
    			   INNER JOIN client USING(client_id)

Запросы с UNION можно использовать как вложенные, это позволяет обрабатывать данные из объединенных запросов совместно

	Пример:		SELECT name_client, MIN(YEAR(first_payment)) AS Год
			FROM
  			   (SELECT name_client, MIN(date_payment) AS first_payment
   			    FROM 
       				buy_archive 
       				INNER JOIN client USING(client_id)
   			GROUP BY  name_client
   			UNION
   			SELECT name_client, MIN(date_step_end)
   			FROM 
       			   buy 
       			   INNER JOIN client USING(client_id)
       			   INNER JOIN buy_step USING (buy_id)
   			   GROUP BY name_client
  			) query_in
			GROUP BY name_client
			HAVING COUNT(*) = 1
			ORDER BY 2



2.5 База данных «Интернет-магазин книг», запросы корректировки

В запросах на добавление можно одновременно заносить и константы, и данные из других таблиц. Для этого в той части запроса INSERT, где задается запрос на выборку,
в качестве полей для вставки указываются не только поля других таблиц, но и  константы:

	INSERT INTO ... 
	SELECT 'Попов Илья', city_id, 'popov@test'
	FROM city
	WHERE ...;
	
	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
		
Для удаления таблицы используется SQL запрос DROP: 

DROP TABLE таблица;

Для изменения структуры таблицы используется оператор ALTER TABLE. С его помощью можно вставить новый столбец, удалить существующий, переименовать столбец и пр.

Для вставки нового столбца используется SQL запросы:

ALTER TABLE таблица ADD имя_столбца тип; - вставляет столбец после последнего
ALTER TABLE таблица ADD имя_столбца тип FIRST; - вставляет столбец перед первым
ALTER TABLE таблица ADD имя_столбца тип AFTER имя_столбца_1; - вставляет столбец после укзанного столбца

Для удаления столбца используется SQL запросы:

ALTER TABLE таблица DROP COLUMN имя_столбца; - удаляет столбец с заданным именем
ALTER TABLE таблица DROP имя_столбца; - ключевое слово COLUMN не обязательно указывать
ALTER TABLE таблица DROP имя_столбца,
                    DROP имя_столбца_1; - удаляет два столбца

Для переименования столбца используется  запрос (тип данных указывать обязательно):

ALTER TABLE таблица CHANGE имя_столбца новое_имя_столбца ТИП ДАННЫХ;

Для изменения типа  столбца используется запрос (два раза указывать имя столбца обязательно): 

ALTER TABLE таблица CHANGE имя_столбца имя_столбца НОВЫЙ_ТИП_ДАННЫХ;

Номер строки в таблице или запросе в некоторых версиях SQL можно получить с помощью оконной функции  row_number()

Нумерацию реализуем с помощью переменных.  Переменные задаются с помощью ключевого слова SET,  перед именем указывается символ @. Например, создадим переменную
@row_num и присвоим ей значение 1:

SET @row_num := 1;
Теперь эту переменную можно использовать в запросах,  кроме того в запросах можно изменить ее значение

	Пример:	SET @row_num := 0;
		SELECT *, (@row_num := @row_num + 1) AS str_num
		FROM  applicant_order;
	
	Выражение  @row_num := @row_num + 1 означает, что для каждой записи, выводимой в запрос, значение переменной @row_num увеличивается на 1. В результате
	получается нумерация строк запроса
